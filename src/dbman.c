#include "bolo.h"
#include <assert.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <arpa/inet.h>

typedef struct PACKED {
	uint32_t  magic;
	uint16_t  version;
	uint16_t  flags;
	uint32_t  timestamp;
	uint32_t  count;
} binf_header_t;

typedef struct PACKED {
	uint16_t  len;
	uint32_t  last_seen;
	 uint8_t  status;
	 uint8_t  stale;
} binf_record_t;

static inline const char *statstr(uint8_t s)
{
	static const char *names[] = { "OK", "WARNING", "CRITICAL", "UNKNOWN" };
	return names[s > 3 ? 3 : s];
}

void save_state(db_t *db, const char *file)
{
	binf_header_t header;
	binf_record_t record;
	char *name; state_t *state;

	int fd = open(file, O_WRONLY|O_CREAT|O_TRUNC, 0640);
	assert(fd >= 0);

	memcpy(&header.magic, "BOLO", 4);
	header.version   = htons(1);
	header.flags     = 0;
	header.timestamp = htonl((uint32_t)time_s());

	/* FIXME: need a hash_len(&h) in libvigor */
	header.count = 0;
	for_each_key_value(&db->states, name, state)
		header.count++;
	header.count = htonl(header.count);

	write(fd, &header, sizeof(header));
	for_each_key_value(&db->states, name, state) {
		size_t l_name    = strlen(name)           + 1;
		size_t l_summary = strlen(state->summary) + 1;
		record.len       = htons(sizeof(binf_record_t) + l_name + l_summary);
		record.last_seen = htonl(state->last_seen);
		record.status    = state->status;
		record.stale     = state->stale;

		write(fd, &record,        sizeof(record));
		write(fd, name,           l_name);
		write(fd, state->summary, l_summary);
	}
	close(fd);
}

int read_state(db_t *db, const char *file)
{
	binf_header_t header;
	binf_record_t record;
	ssize_t n;

	int fd = open(file, O_RDONLY);
	if (fd < 0)
		return -1;

	n = read(fd, &header, sizeof(header));
	if (n < 4 || memcmp(&header.magic, "BOLO", 4) != 0)
		goto fail;

	if (n != sizeof(header))
		goto fail;

	header.version   = ntohs(header.version);
	header.flags     = ntohs(header.flags);
	header.timestamp = ntohl(header.timestamp);
	header.count     = ntohl(header.count);

	if (header.version != 1)
		goto fail;

	while (header.count-- > 0) {
		n = read(fd, &record, sizeof(record));
		if (n != sizeof(record))
			goto fail;

		record.len       = ntohs(record.len);
		record.last_seen = ntohl(record.last_seen);
		if (record.len == 0 || record.len < sizeof(binf_record_t))
			goto fail;

		size_t rest = record.len - sizeof(binf_record_t);
		char *strings = calloc(rest, sizeof(char));
		n = read(fd, strings, rest);
		if (n != rest) {
			free(strings);
			goto fail;
		}

		state_t *s = hash_get(&db->states, strings);
		if (s) {
			s->summary   = strdup(strings + strlen(strings) + 1);
			s->last_seen = record.last_seen;
			s->status    = record.status;
			s->stale     = record.stale;
		}
		free(strings);
	}

	close(fd);
	return 0;

fail:
	close(fd);
	return -1;
}

void check_freshness(db_t *db)
{
	state_t *state;
	char *k;
	uint32_t now = time_s();

	for_each_key_value(&db->states, k, state) {
		if (state->expiry > now) continue;

		state->stale   = 1;
		state->expiry  = now + state->type->freshness;
		state->status  = state->type->status;
		free(state->summary);
		state->summary = strdup(state->type->summary);
	}
}

void dump(db_t *db, const char *file)
{
	assert(file);
	int fd = open(file, O_WRONLY|O_CREAT|O_EXCL, 0644);
	assert(fd >= 0);

	FILE *io = fdopen(fd, "w");
	assert(io);
	fprintf(io, "---\n");
	fprintf(io, "# generated by bolo\n");

	char *name; state_t *state;
	for_each_key_value(&db->states, name, state) {
		fprintf(io, "%s:\n", name);
		fprintf(io, "  status:    %s\n", statstr(state->status));
		fprintf(io, "  message:   %s\n", state->summary);
		fprintf(io, "  last_seen: %i\n", state->last_seen);
		fprintf(io, "  fresh:     %s\n", state->stale ? "no" : "yes");
	}

	fclose(io);
	close(fd);
}

int update(db_t *db, uint32_t ts, const char *name, uint8_t code, const char *msg)
{
	assert(name);
	assert(msg);
	state_t *state;

	state = hash_get(&db->states, name);
	if (!state) return -1;

	free(state->summary);
	state->status    = code;
	state->summary   = strdup(msg);
	state->last_seen = ts;
	state->expiry    = ts + state->type->freshness;
	state->stale     = 0;
	return 0;
}

void* db_manager(void *u)
{
	int rc;
	server_t *s = (server_t*)u;

	void *z = zmq_socket(s->zmq, ZMQ_ROUTER);
	assert(z);
	rc = zmq_bind(z, DB_MANAGER_ENDPOINT);
	assert(rc == 0);

	rc = read_state(&s->db, s->config.savefile);

	pdu_t *q, *a;
	while ((q = pdu_recv(z)) != NULL) {
		if (strcmp(pdu_type(q), "UPDATE") == 0) {
			char *ts   = pdu_string(q, 1);
			char *name = pdu_string(q, 2);
			char *code = pdu_string(q, 3);
			char *msg  = pdu_string(q, 4);

			if (update(&s->db, strtol(ts, NULL, 10), name, atoi(code), msg) == 0)
				a = pdu_reply(q, "OK", 0);
			else
				a = pdu_reply(q, "ERROR", 1, "State Not Found");

			free(ts);
			free(name);
			free(code);
			free(msg);

		} else if (strcmp(pdu_type(q), "STATE") == 0) {
			char *name = pdu_string(q, 1);
			state_t *state = hash_get(&s->db.states, name);
			if (!state) {
				a = pdu_reply(q, "ERROR", 1, "State Not Found");
			} else {
				a = pdu_reply(q, "STATE", 1, name);
				pdu_extendf(a, "%li", state->last_seen);
				pdu_extendf(a, "%s",  state->stale ? "no" : "yes");
				pdu_extendf(a, "%s",  statstr(state->status));
				pdu_extendf(a, "%s",  state->summary);
			}

		} else if (strcmp(pdu_type(q), "DUMP") == 0) {
			char *key  = pdu_string(q, 1);
			char *file = string(s->config.dumpfiles, key);
			free(key);

			dump(&s->db, file);
			a = pdu_reply(q, "DUMP", 1, file);
			free(file);

		} else if (strcmp(pdu_type(q), "CHECKFRESH") == 0) {
			check_freshness(&s->db);
			a = pdu_reply(q, "OK", 0);

		} else if (strcmp(pdu_type(q), "SAVESTATE") == 0) {
			save_state(&s->db, s->config.savefile);
			a = pdu_reply(q, "OK", 0);

		} else {
			a = pdu_reply(q, "ERROR", 1, "Invalid PDU");
		}

		pdu_send_and_free(a, z);
		pdu_free(q);
	}

	return NULL; /* LCOV_EXCL_LINE */
}
