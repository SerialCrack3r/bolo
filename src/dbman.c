#include "bolo.h"
#include <assert.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>

static inline const char *statstr(uint8_t s)
{
	static const char *names[] = { "OK", "WARNING", "CRITICAL", "UNKNOWN" };
	return names[s > 3 ? 3 : s];
}

void dump(db_t *db, const char *file)
{
	assert(file);
	int fd = open(file, O_WRONLY|O_CREAT|O_EXCL, 0644);
	assert(fd >= 0);

	FILE *io = fdopen(fd, "w");
	assert(io);
	fprintf(io, "---\n");
	fprintf(io, "# generated by bolo\n");

	char *k; state_t *state;
	for_each_key_value(&db->states, k, state) {
		fprintf(io, "%s:\n", state->name);
		fprintf(io, "  status:    %s\n",  statstr(state->status));
		fprintf(io, "  message:   %s\n",  state->summary);
		fprintf(io, "  last_seen: %li\n", state->last_seen);
		fprintf(io, "  fresh:     %s\n",  state->stale ? "no" : "yes");
	}

	fclose(io);
	close(fd);
}

void update(db_t *db, int64_t ts, const char *name, uint8_t code, const char *msg)
{
	assert(name);
	assert(msg);
	state_t *state;

	state = hash_get(&db->states, name);
	if (!state) {
		state = calloc(1, sizeof(state_t));
		state->name = strdup(name);
		state->type = NULL; /* FIXME */
		hash_set(&db->states, name, state);
	}

	free(state->summary);
	state->status    = code;
	state->summary   = strdup(msg);
	state->last_seen = ts;
	state->expiry    = 0; /* FIXME */
	state->stale     = 0;
	return;
}

void* db_manager(void *u)
{
	db_t db;
	int rc;
	server_t *s = (server_t*)u;

	void *z = zmq_socket(s->zmq, ZMQ_ROUTER);
	assert(z);
	rc = zmq_bind(z, DB_MANAGER_ENDPOINT);
	assert(rc == 0);

	pdu_t *q, *a;
	while ((q = pdu_recv(z)) != NULL) {
		if (strcmp(pdu_type(q), "UPDATE") == 0) {
			char *ts   = pdu_string(q, 1);
			char *name = pdu_string(q, 2);
			char *code = pdu_string(q, 3);
			char *msg  = pdu_string(q, 4);

			update(&db, strtol(ts, NULL, 10), name, atoi(code), msg);
			free(ts);
			free(name);
			free(code);
			free(msg);

			a = pdu_reply(q, "OK", 0);

		} else if (strcmp(pdu_type(q), "STATE") == 0) {
			char *name = pdu_string(q, 1);
			state_t *state = hash_get(&db.states, name);
			if (!state) {
				a = pdu_reply(q, "ERROR", 1, "State Not Found");
			} else {
				a = pdu_reply(q, "STATE", 1, state->name);
				pdu_extendf(a, "%li", state->last_seen);
				pdu_extendf(a, "%s",  state->stale ? "no" : "yes");
				pdu_extendf(a, "%s",  statstr(state->status));
				pdu_extendf(a, "%s",  state->summary);
			}

		} else if (strcmp(pdu_type(q), "DUMP") == 0) {
			char *key  = pdu_string(q, 1);
			char *file = string(s->dumpfile_fmt, key);
			free(key);

			dump(&db, file);
			a = pdu_reply(q, "DUMP", 1, file);
			free(file);

		} else if (strcmp(pdu_type(q), "CHECKFRESH") == 0) {
			a = pdu_reply(q, "ERROR", 1, "Not Implemented");

		} else if (strcmp(pdu_type(q), "SAVESTATE") == 0) {
			a = pdu_reply(q, "ERROR", 1, "Not Implemented");

		} else {
			a = pdu_reply(q, "ERROR", 1, "Invalid PDU");
		}

		pdu_send_and_free(a, z);
		pdu_free(q);
	}

	return NULL;
}
