#include "bolo.h"
#include <assert.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <arpa/inet.h>

typedef struct PACKED {
	uint32_t  magic;
	uint16_t  version;
	uint16_t  flags;
	uint32_t  timestamp;
	uint32_t  count;
} binf_header_t;

typedef struct PACKED {
	uint16_t  len;
	uint32_t  last_seen;
	 uint8_t  status;
	 uint8_t  stale;
} binf_record_t;

static inline const char *statstr(uint8_t s)
{
	static const char *names[] = { "OK", "WARNING", "CRITICAL", "UNKNOWN" };
	return names[s > 3 ? 3 : s];
}

void save_state(db_t *db, const char *file)
{
	binf_header_t header;
	binf_record_t record;
	char *k; state_t *v;

	int fd = open(file, O_WRONLY|O_CREAT|O_TRUNC, 0640);
	assert(fd >= 0);

	memcpy(&header.magic, "BOLO", 4);
	header.version   = htons(1);
	header.flags     = 0;
	header.timestamp = htonl((uint32_t)time_s());

	/* FIXME: need a hash_len(&h) in libvigor */
	header.count = 0;
	for_each_key_value(&db->states, k, v)
		header.count++;
	header.count = htonl(header.count);

	write(fd, &header, sizeof(header));
	for_each_key_value(&db->states, k, v) {
		size_t l_name    = strlen(v->name)    + 1;
		size_t l_summary = strlen(v->summary) + 1;
		record.len       = htons(sizeof(binf_record_t) + l_name + l_summary);
		record.last_seen = htonl(v->last_seen);
		record.status    = v->status;
		record.stale     = v->stale;

		write(fd, &record,    sizeof(record));
		write(fd, v->name,    l_name);
		write(fd, v->summary, l_summary);
	}
	close(fd);
}

int read_state(db_t *db, const char *file)
{
	binf_header_t header;
	binf_record_t record;
	ssize_t n;

	int fd = open(file, O_RDONLY);
	if (fd < 0)
		return -1;

	n = read(fd, &header, sizeof(header));
	if (n < 4 || memcmp(&header.magic, "BOLO", 4) != 0)
		goto fail;

	if (n != sizeof(header))
		goto fail;

	header.version   = ntohs(header.version);
	header.flags     = ntohs(header.flags);
	header.timestamp = ntohl(header.timestamp);
	header.count     = ntohl(header.count);

	if (header.version != 1)
		goto fail;

	while (header.count-- > 0) {
		n = read(fd, &record, sizeof(record));
		if (n != sizeof(record))
			goto fail;

		record.len       = ntohs(record.len);
		record.last_seen = ntohl(record.last_seen);
		if (record.len == 0 || record.len < sizeof(binf_record_t))
			goto fail;

		size_t rest = record.len - sizeof(binf_record_t);
		char *strings = calloc(rest, sizeof(char));
		n = read(fd, strings, rest);
		if (n != rest) {
			free(strings);
			goto fail;
		}

		state_t *s = calloc(1, sizeof(state_t));
		s->name      = strdup(strings);
		s->summary   = strdup(strings + strlen(s->name) + 1);
		s->last_seen = record.last_seen;
		s->status    = record.status;
		s->stale     = record.stale;
		s->type      = NULL; /* FIXME */
		free(strings);

		hash_set(&db->states, s->name, s);
	}

	close(fd);
	return 0;

fail:
	close(fd);
	return -1;
}

void dump(db_t *db, const char *file)
{
	assert(file);
	int fd = open(file, O_WRONLY|O_CREAT|O_EXCL, 0644);
	assert(fd >= 0);

	FILE *io = fdopen(fd, "w");
	assert(io);
	fprintf(io, "---\n");
	fprintf(io, "# generated by bolo\n");

	char *k; state_t *state;
	for_each_key_value(&db->states, k, state) {
		fprintf(io, "%s:\n", state->name);
		fprintf(io, "  status:    %s\n", statstr(state->status));
		fprintf(io, "  message:   %s\n", state->summary);
		fprintf(io, "  last_seen: %i\n", state->last_seen);
		fprintf(io, "  fresh:     %s\n", state->stale ? "no" : "yes");
	}

	fclose(io);
	close(fd);
}

void update(db_t *db, uint32_t ts, const char *name, uint8_t code, const char *msg)
{
	assert(name);
	assert(msg);
	state_t *state;

	state = hash_get(&db->states, name);
	if (!state) {
		state = calloc(1, sizeof(state_t));
		state->name = strdup(name);
		state->type = NULL; /* FIXME */
		hash_set(&db->states, name, state);
	}

	free(state->summary);
	state->status    = code;
	state->summary   = strdup(msg);
	state->last_seen = ts;
	state->expiry    = 0; /* FIXME */
	state->stale     = 0;
	return;
}

void* db_manager(void *u)
{
	int rc;
	server_t *s = (server_t*)u;

	void *z = zmq_socket(s->zmq, ZMQ_ROUTER);
	assert(z);
	rc = zmq_bind(z, DB_MANAGER_ENDPOINT);
	assert(rc == 0);

	db_t db;
	memset(&db, 0, sizeof(db));
	rc = read_state(&db, s->savefile);

	pdu_t *q, *a;
	while ((q = pdu_recv(z)) != NULL) {
		if (strcmp(pdu_type(q), "UPDATE") == 0) {
			char *ts   = pdu_string(q, 1);
			char *name = pdu_string(q, 2);
			char *code = pdu_string(q, 3);
			char *msg  = pdu_string(q, 4);

			update(&db, strtol(ts, NULL, 10), name, atoi(code), msg);
			free(ts);
			free(name);
			free(code);
			free(msg);

			a = pdu_reply(q, "OK", 0);

		} else if (strcmp(pdu_type(q), "STATE") == 0) {
			char *name = pdu_string(q, 1);
			state_t *state = hash_get(&db.states, name);
			if (!state) {
				a = pdu_reply(q, "ERROR", 1, "State Not Found");
			} else {
				a = pdu_reply(q, "STATE", 1, state->name);
				pdu_extendf(a, "%li", state->last_seen);
				pdu_extendf(a, "%s",  state->stale ? "no" : "yes");
				pdu_extendf(a, "%s",  statstr(state->status));
				pdu_extendf(a, "%s",  state->summary);
			}

		} else if (strcmp(pdu_type(q), "DUMP") == 0) {
			char *key  = pdu_string(q, 1);
			char *file = string(s->dumpfile_fmt, key);
			free(key);

			dump(&db, file);
			a = pdu_reply(q, "DUMP", 1, file);
			free(file);

		} else if (strcmp(pdu_type(q), "CHECKFRESH") == 0) {
			a = pdu_reply(q, "ERROR", 1, "Not Implemented");

		} else if (strcmp(pdu_type(q), "SAVESTATE") == 0) {
			save_state(&db, s->savefile);
			a = pdu_reply(q, "OK", 0);

		} else {
			a = pdu_reply(q, "ERROR", 1, "Invalid PDU");
		}

		pdu_send_and_free(a, z);
		pdu_free(q);
	}

	return NULL; /* LCOV_EXCL_LINE */
}
