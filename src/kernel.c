/*
  Copyright 2015 James Hunt <james@jameshunt.us>

  This file is part of Bolo.

  Bolo is free software: you can redistribute it and/or modify it under the
  terms of the GNU General Public License as published by the Free Software
  Foundation, either version 3 of the License, or (at your option) any later
  version.

  Bolo is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
  details.

  You should have received a copy of the GNU General Public License along
  with Bolo.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "bolo.h"
#include <arpa/inet.h>

typedef struct {
	server_t *server;
	void     *listener;
	void     *broadcast;
} kernel_t;

static void broadcast_state(kernel_t*, state_t*);
static void broadcast_transition(kernel_t*, state_t*);
static void broadcast_event(kernel_t*, event_t*);

static inline const char *statstr(uint8_t s)
{
	static const char *names[] = { "OK", "WARNING", "CRITICAL", "UNKNOWN" };
	return names[s > 3 ? 3 : s];
}

static int save_keys(hash_t *keys, const char *file)
{
	FILE *io = fopen(file, "w");
	if (!io) {
		logger(LOG_ERR, "kernel failed to open keys file %s for writing: %s",
				file, strerror(errno));
		return -1;
	}

	logger(LOG_NOTICE, "saving keys to %s", file);
	fprintf(io, "# generated %lu\n", time_ms());

	unsigned long n = 0;
	char *key, *value;
	for_each_key_value(keys, key, value) {
		if (!value) continue;
		fprintf(io, "%s = %s\n", key, value);
		n++;
	}
	fprintf(io, "# %lu keys\n", n);
	fclose(io);
	return 0;
}

static int read_keys(hash_t *keys, const char *file)
{
	FILE *io = fopen(file, "r");
	if (!io) {
		logger(LOG_ERR, "kernel failed to open %s for reading: %s",
			file, strerror(errno));
		return -1;
	}

	logger(LOG_NOTICE, "reading keys from %s", file);

	char buf[8192];
	while (fgets(buf, 8192, io)) {
		char *k, *v, *nl;
		k = buf;

		while (*k && isspace(*k)) k++;
		if (*k == '#') continue;

		v = k;
		while (*v && !isspace(*v)) v++;
		*v++ = '\0';
		while (*v && isspace(*v)) v++;
		if (*v++ != '=') continue;
		while (*v && isspace(*v)) v++;

		nl = v;
		while (*nl && *nl != '\n') nl++;
		*nl = '\0';

		hash_set(keys, k, strdup(v));
	}

	fclose(io);
	return 0;
}

static void check_freshness(kernel_t *k)
{
	state_t *state;
	char *key;
	int32_t now = time_s();

	logger(LOG_INFO, "checking freshness");
	for_each_key_value(&k->server->db.states, key, state) {
		if (state->expiry > now) continue;

		int transition = !state->stale || state->status != state->type->status;

		logger(LOG_INFO, "state %s is stale; marking", key);
		state->stale   = 1;
		state->expiry  = now + state->type->freshness;
		state->status  = state->type->status;
		free(state->summary);
		state->summary = strdup(state->type->summary);

		if (transition)
			broadcast_transition(k, state);
		broadcast_state(k, state);
	}
}

static void dump(db_t *db, const char *file)
{
	if (!file) {
		logger(LOG_ERR, "kernel cannot dump state; no dump file name provided");
		return;
	}
	int fd = open(file, O_WRONLY|O_CREAT|O_EXCL, 0644);
	if (fd < 0) {
		logger(LOG_ERR, "kernel cannot dump state; unable to open %s for writing: %s",
				file, strerror(errno));
		return;
	}

	FILE *io = fdopen(fd, "w");
	if (!io) {
		logger(LOG_ERR, "kernel cannot dump state; failed to open %s for writing: %s",
				file, strerror(errno));
		return;
	}

	logger(LOG_NOTICE, "dumping state data, in YAML format, to %s", file);
	fprintf(io, "---\n");
	fprintf(io, "# generated by bolo\n");

	char *name; state_t *state;
	for_each_key_value(&db->states, name, state) {
		fprintf(io, "%s:\n", name);
		fprintf(io, "  status:    %s\n", statstr(state->status));
		fprintf(io, "  message:   %s\n", state->summary);
		fprintf(io, "  last_seen: %i\n", state->last_seen);
		fprintf(io, "  fresh:     %s\n", state->stale ? "no" : "yes");
	}

	fclose(io);
	close(fd);
}

static void dump_events(db_t *db, const char *file, int32_t since)
{
	if (!file) {
		logger(LOG_ERR, "kernel cannot dump events; no dump file name provided");
		return;
	}
	int fd = open(file, O_WRONLY|O_CREAT|O_EXCL, 0644);
	if (fd < 0) {
		logger(LOG_ERR, "kernel cannot dump events; unable to open %s for writing: %s",
				file, strerror(errno));
		return;
	}

	FILE *io = fdopen(fd, "w");
	if (!io) {
		logger(LOG_ERR, "kernel cannot dump events; failed to open %s for writing: %s",
				file, strerror(errno));
		return;
	}

	logger(LOG_NOTICE, "dumping event data, in YAML format, to %s", file);
	fprintf(io, "---\n");
	fprintf(io, "# generated by bolo\n");

	event_t *ev;
	for_each_object(ev, &db->events, l) {
		if (ev->timestamp < since)
			continue;

		fprintf(io, "- name:  %s\n", ev->name);
		fprintf(io, "  when:  %i\n", ev->timestamp);
		fprintf(io, "  extra: %s\n", ev->extra);
	}

	fclose(io);
	close(fd);
}

static void event_free(event_t *ev)
{
	if (!ev) return;
	list_delete(&ev->l);
	free(ev->name);
	free(ev->extra);
	free(ev);
}

static void buffer_event(db_t *db, event_t *ev, int max, int keep)
{
	if (max > 0) {
		list_push(&db->events, &ev->l);
		db->events_count++;

		if (keep == EVENTS_KEEP_NUMBER) {
			while (db->events_count > max) {
				event_free(list_head(&db->events, event_t, l));
				db->events_count--;
			}

		} else {
			int32_t now  = ev->timestamp;

			for (;;) {
				ev = list_head(&db->events, event_t, l);
				if (ev->timestamp > now - max) break;
				event_free(ev);
				db->events_count--;
			}
		}
	}
}

#define winstart(x, t) ((t) - ((t) % (x)->window->time))
#define winend(x, t)   (winstart((x), (t)) + (x)->window->time)
#define max(a,b) ((a) > (b) ? (a) : (b))
#define min(a,b) ((a) < (b) ? (a) : (b))

static void broadcast_state(kernel_t *k, state_t *state)
{
	logger(LOG_INFO, "broadcasting [STATE] data for %s: "
		"ts=%i, stale=%s, status=%i, summary=%s",
		state->name, state->last_seen, state->stale ? "y" : "n",
		state->status, state->summary);

	pdu_t *p = pdu_make("STATE", 1, state->name);
	pdu_extendf(p, "%li", state->last_seen);
	pdu_extendf(p, "%s",  state->stale ? "stale" : "fresh");
	pdu_extendf(p, "%s",  statstr(state->status));
	pdu_extendf(p, "%s",  state->summary);
	pdu_send_and_free(p, k->broadcast);
}

static void broadcast_transition(kernel_t *k, state_t *state)
{
	logger(LOG_INFO, "broadcasting [TRANSITION] data for %s: "
		"ts=%i, stale=%s, status=%i, summary=%s",
		state->name, state->last_seen, state->stale ? "y" : "n",
		state->status, state->summary);

	pdu_t *p = pdu_make("TRANSITION", 1, state->name);
	pdu_extendf(p, "%li", state->last_seen);
	pdu_extendf(p, "%s",  state->stale ? "stale" : "fresh");
	pdu_extendf(p, "%s",  statstr(state->status));
	pdu_extendf(p, "%s",  state->summary);
	pdu_send_and_free(p, k->broadcast);
}

static void broadcast_event(kernel_t *k, event_t *ev)
{
	logger(LOG_INFO, "broadcasting [EVENT] data for %s: ts=%i, extra='%s'",
		ev->name, ev->timestamp, ev->extra);

	pdu_t *p = pdu_make("EVENT", 0);
	pdu_extendf(p, "%i", ev->timestamp);
	pdu_extendf(p, "%s", ev->name);
	pdu_extendf(p, "%s", ev->extra);
	pdu_send_and_free(p, k->broadcast);
}

static void broadcast_counter(kernel_t *k, counter_t *counter)
{
	int32_t ts = winstart(counter, counter->last_seen);

	logger(LOG_INFO, "broadcasting [COUNTER] data for %s: "
		"ts=%i, value=%i",
		counter->name, ts, counter->value);

	pdu_t *p = pdu_make("COUNTER", 0);
	pdu_extendf(p, "%u",  ts);
	pdu_extendf(p, "%s",  counter->name);
	pdu_extendf(p, "%lu", counter->value);
	pdu_send_and_free(p, k->broadcast);
}

static void broadcast_sample(kernel_t *k, sample_t *sample)
{
	int32_t ts = winstart(sample, sample->last_seen);

	logger(LOG_INFO, "broadcasting [SAMPLE] data for %s: "
		"ts=%i, n=%i, min=%e, max=%e, sum=%e, mean=%e, var=%e",
		sample->name, ts, sample->n, sample->min,
		sample->max, sample->sum, sample->mean, sample->var);

	pdu_t *p = pdu_make("SAMPLE", 0);
	pdu_extendf(p, "%u", ts);
	pdu_extendf(p, "%s", sample->name);
	pdu_extendf(p, "%u", sample->n);
	pdu_extendf(p, "%e", sample->min);
	pdu_extendf(p, "%e", sample->max);
	pdu_extendf(p, "%e", sample->sum);
	pdu_extendf(p, "%e", sample->mean);
	pdu_extendf(p, "%e", sample->var);
	pdu_send_and_free(p, k->broadcast);
}

static void broadcast_rate(kernel_t *k, rate_t *rate)
{
	int32_t ts = winstart(rate, rate->last_seen);
	double v = rate_calc(rate, rate->window->time);

	logger(LOG_INFO, "broadcasting [RATE] data for %s: "
		"ts=%i, first=%lu, last=%lu, per/%li=%e",
		rate->name, ts, rate->first, rate->last, rate->window->time, v);

	pdu_t *p = pdu_make("RATE", 0);
	pdu_extendf(p, "%u", ts);
	pdu_extendf(p, "%s", rate->name);
	pdu_extendf(p, "%i", rate->window->time);
	pdu_extendf(p, "%e", v);
	pdu_send_and_free(p, k->broadcast);
}

static void cleanup_kernel(void *_)
{
	kernel_t *k = (kernel_t*)_;

	if (k->listener) {
		logger(LOG_INFO, "kernel cleaning up; closing listening socket");
		vzmq_shutdown(k->listener, 500);
		k->listener = NULL;
	}
	if (k->broadcast) {
		logger(LOG_INFO, "kernel cleaning up; closing broadcast socket");
		vzmq_shutdown(k->broadcast, 0);
		k->broadcast = NULL;
	}
	if (k->server) {
		logger(LOG_INFO, "kernel cleaning up; saving final state to %s",
			k->server->config.savefile);
		if (binf_write(&k->server->db, k->server->config.savefile) != 0) {
			logger(LOG_CRIT, "failed to save final state to %s: %s",
				k->server->config.savefile, strerror(errno));
		}

		logger(LOG_INFO, "kernel cleaning up; saving keys to %s",
			k->server->config.keysfile);
		if (save_keys(&k->server->keys, k->server->config.keysfile) != 0) {
			logger(LOG_CRIT, "failed to save keys to %s: %s",
				k->server->config.keysfile, strerror(errno));
		}

		logger(LOG_INFO, "kernel cleaning up; freeing EVENT memory");
		event_t *ev, *ev_tmp;
		for_each_object_safe(ev, ev_tmp, &k->server->db.events, l) {
			free(ev->name);
			free(ev->extra);
			free(ev);
		}

		logger(LOG_INFO, "kernel cleaning up; freeing KEY memory");
		hash_done(&k->server->keys, 1);
	}

	free(k);
}

void* kernel(void *u)
{
	kernel_t *k = calloc(1, sizeof(kernel_t));
	pthread_cleanup_push(cleanup_kernel, k);

	k->server = (server_t*)u;
	if (!k->server) {
		logger(LOG_CRIT, "kernel failed: server context was NULL");
		return NULL;
	}

	k->listener = zmq_socket(k->server->zmq, ZMQ_ROUTER);
	if (!k->listener) {
		logger(LOG_CRIT, "kernel failed to get a ROUTER socket");
		return NULL;
	}
	if (zmq_bind(k->listener, KERNEL_ENDPOINT) != 0) {
		logger(LOG_CRIT, "kernel failed to bind to " KERNEL_ENDPOINT);
		return NULL;
	}

	if (!k->server->config.broadcast) {
		logger(LOG_CRIT, "kernel failed: no broadcast bind address specified");
		return NULL;
	}
	logger(LOG_INFO, "binding broadcast socket %s", k->server->config.broadcast);
	k->broadcast = zmq_socket(k->server->zmq, ZMQ_PUB);
	if (!k->broadcast) {
		logger(LOG_CRIT, "kernel failed to get a PUB socket");
		return NULL;
	}
	if (zmq_bind(k->broadcast, k->server->config.broadcast) != 0) {
		logger(LOG_CRIT, "kernel failed to bind to %s", k->server->config.broadcast);
		return NULL;
	}

	if (!k->server->config.savefile) {
		logger(LOG_CRIT, "kernel failed: no savefile provided");
		return NULL;
	}
	if (binf_read(&k->server->db, k->server->config.savefile) != 0) {
		logger(LOG_WARNING, "kernel failed to read state from %s: %s",
				k->server->config.savefile, strerror(errno));
	}

	if (!k->server->config.keysfile) {
		logger(LOG_CRIT, "kernel failed: no keysfile provided");
		return NULL;
	}
	if (read_keys(&k->server->keys, k->server->config.keysfile) != 0) {
		logger(LOG_WARNING, "kernel failed to read keys from %s: %s",
				k->server->config.keysfile, strerror(errno));
	}

	pdu_t *q, *a;
	while ((q = pdu_recv(k->listener)) != NULL) {
		if (!pdu_type(q)) {
			logger(LOG_ERR, "kernel received an empty PDU; ignoring");
			pdu_free(q);
			continue;
		}

		logger(LOG_DEBUG, "received a [%s] PDU", pdu_type(q));
		if (strcmp(pdu_type(q), "PUT.STATE") == 0 && pdu_size(q) == 5) {
			char *s;

			s = pdu_string(q, 1); int32_t ts   = strtol(s, NULL, 10); free(s);
			s = pdu_string(q, 3); uint8_t code = atoi(s); free(s);
			char *name = pdu_string(q, 2);
			char *msg  = pdu_string(q, 4);

			if (!name || !*name) {
				a = pdu_reply(q, "ERROR", 1, "No state name given");

			} else if (!msg || !*msg) {
				a = pdu_reply(q, "ERROR", 1, "No summary given");

			} else {
				state_t *state = find_state(&k->server->db, name);
				if (state) {
					logger(LOG_INFO, "updating state %s, status=%i, ts=%i, msg=[%s]", name, code, ts, msg);
					int transition = state->stale || state->status != code;

					free(state->summary);
					state->status    = code;
					state->summary   = strdup(msg);
					state->last_seen = ts;
					state->expiry    = ts + state->type->freshness;
					state->stale     = 0;

					a = pdu_reply(q, "OK", 0);
					if (transition)
						broadcast_transition(k, state);
					broadcast_state(k, state);

				} else {
					a = pdu_reply(q, "ERROR", 1, "State Not Found");
					logger(LOG_INFO, "ignoring update for unknown state %s, status=%i, ts=%i, msg=[%s]", name, code, ts, msg);
				}
			}

			free(name);
			free(msg);

		} else if (strcmp(pdu_type(q), "PUT.COUNTER") == 0 && pdu_size(q) == 4) {
			char *s;
			s = pdu_string(q, 1); int32_t ts   = strtol(s, NULL, 10); free(s);
			s = pdu_string(q, 3); int32_t incr = strtol(s, NULL, 10); free(s);
			char *name = pdu_string(q, 2);

			if (!name || !*name) {
				a = pdu_reply(q, "ERROR", 1, "No counter name given");
			} else {
				counter_t *counter = find_counter(&k->server->db, name);
				if (counter) {
					/* check for window closure */
					if (counter->last_seen > 0 && counter->last_seen != ts
					 && winstart(counter, counter->last_seen) != winstart(counter, ts)) {
						logger(LOG_INFO, "counter window rollover detected between %i and %i",
							winstart(counter, counter->last_seen), ts);
						broadcast_counter(k, counter);
						counter_reset(counter);
					}

					logger(LOG_INFO, "updating counter %s, ts=%i, incr=%i", name, ts, incr);
					counter->last_seen = ts;
					counter->value += incr;

					a = pdu_reply(q, "OK", 0);

				} else {
					a = pdu_reply(q, "ERROR", 1, "Counter Not Found");
					logger(LOG_WARNING, "ignoring update for unknown counter %s, ts=%i, incr=%i", name, ts, incr);
				}
			}
			free(name);

		} else if (strcmp(pdu_type(q), "PUT.SAMPLE") == 0 && pdu_size(q) == 4) {
			char *s;
			s = pdu_string(q, 1); int32_t ts = strtol(s, NULL, 10); free(s);
			s = pdu_string(q, 3); double v   = strtod(s, NULL);     free(s);
			char *name = pdu_string(q, 2);

			if (!name || !*name) {
				a = pdu_reply(q, "ERROR", 1, "No sample name given");
			} else {
				sample_t *sample = find_sample(&k->server->db, name);
				if (sample) {
					/* check for window closure */
					if (sample->last_seen > 0 && sample->last_seen != ts
					 && winstart(sample, sample->last_seen) != winstart(sample, ts)) {
						logger(LOG_INFO, "sample window rollover detected between %i and %i",
							winstart(sample, sample->last_seen), ts);
						broadcast_sample(k, sample);
						sample_reset(sample);
					}

					logger(LOG_INFO, "%s sample set %s, ts=%i, value=%e", (sample->last_seen ? "updating" : "starting"), name, ts, v);
					if (sample_data(sample, v) != 0) {
						logger(LOG_ERR, "failed to update sample set %s, ts=%i, value=%e", name, ts, v);
						a = pdu_reply(q, "ERROR", 1, "Internal error");
					} else {
						sample->last_seen = ts;
						a = pdu_reply(q, "OK", 0);
					}

				} else {
					a = pdu_reply(q, "ERROR", 1, "Sample Not Found");
					logger(LOG_WARNING, "ignoring update for unknown sample set %s, ts=%i, value=%e", name, ts, v);
				}
			}
			free(name);

		} else if (strcmp(pdu_type(q), "PUT.RATE") == 0 && pdu_size(q) == 4) {
			char *s;
			s = pdu_string(q, 1); int32_t ts = strtol(  s, NULL, 10); free(s);
			s = pdu_string(q, 3); uint64_t v = strtoull(s, NULL, 10); free(s);
			char *name = pdu_string(q, 2);

			if (!name || !*name) {
				a = pdu_reply(q, "ERROR", 1, "No rate name given");
			} else {
				rate_t *rate = find_rate(&k->server->db, name);
				if (rate) {
					/* check for window closure */
					if (rate->last_seen > 0 && rate->last_seen != ts
					 && winstart(rate, rate->last_seen) != winstart(rate, ts)) {
						logger(LOG_INFO, "rate window rollover detected between %i and %i",
							winstart(rate, rate->last_seen), ts);
						broadcast_rate(k, rate);
						rate_reset(rate);
					}

					if (!rate->first_seen)
						rate->first_seen = ts;
					logger(LOG_INFO, "%s rate set %s, ts=%i, value=%lu", (rate->last_seen ? "updating" : "starting"), name, ts, v);
					if (rate_data(rate, v) != 0) {
						logger(LOG_ERR, "failed to update rate set %s, ts=%i, value=%lu", name, ts, v);
						a = pdu_reply(q, "ERROR", 1, "Internal error");
					} else {
						rate->last_seen = ts;
						a = pdu_reply(q, "OK", 0);
					}

				} else {
					a = pdu_reply(q, "ERROR", 1, "Rate Not Found");
					logger(LOG_WARNING, "ignoring update for unknown rate set %s, ts=%i, value=%lu", name, ts, v);
				}
			}
			free(name);

		} else if (strcmp(pdu_type(q), "NEW.EVENT") == 0 && pdu_size(q) == 4) {
			event_t *ev = vmalloc(sizeof(event_t));

			char *s = pdu_string(q, 1); ev->timestamp = strtol(s, NULL, 10); free(s);
			ev->name  = pdu_string(q, 2);
			ev->extra = pdu_string(q, 3);
			broadcast_event(k, ev);

			buffer_event(&k->server->db, ev,
				k->server->config.events_max, k->server->config.events_keep);
			a = pdu_reply(q, "OK", 0);

		} else if (strcmp(pdu_type(q), "GET.EVENTS") == 0 && pdu_size(q) == 3) {
			char *key  = pdu_string(q, 1);
			char *file = string(k->server->config.dumpfiles, key); free(key);
			char *s = pdu_string(q, 2); int32_t ts = strtol(s, NULL, 10); free(s);

			dump_events(&k->server->db, file, ts);
			a = pdu_reply(q, "EVENTS", 1, file);
			free(file);

		} else if (strcmp(pdu_type(q), "GET.STATE") == 0 && pdu_size(q) == 2) {
			char *name = pdu_string(q, 1);
			state_t *state = hash_get(&k->server->db.states, name);
			if (!state) {
				a = pdu_reply(q, "ERROR", 1, "State Not Found");
			} else {
				a = pdu_reply(q, "STATE", 1, name);
				pdu_extendf(a, "%li", state->last_seen);
				pdu_extendf(a, "%s",  state->stale ? "stale" : "fresh");
				pdu_extendf(a, "%s",  statstr(state->status));
				pdu_extendf(a, "%s",  state->summary);
			}
			free(name);

		} else if (strcmp(pdu_type(q), "GET.KEYS") == 0 && pdu_size(q) > 1) {
			a = pdu_reply(q, "VALUES", 0);
			int i; char *key, *value;

			for (i = 1; i < pdu_size(q); i++) {
				key = pdu_string(q, i);
				value = hash_get(&k->server->keys, key);
				if (value) {
					pdu_extendf(a, "%s", key);
					pdu_extendf(a, "%s", value);
				}
				free(key);
			}

		} else if (strcmp(pdu_type(q), "SET.KEYS") == 0 && pdu_size(q) > 2 && (pdu_size(q) - 1) % 2 == 0) {
			char *key, *value;
			int i;
			for (i = 1; i < pdu_size(q); i += 2) {
				key   = pdu_string(q, i);
				value = pdu_string(q, i + 1);

				logger(LOG_INFO, "set key %s = '%s'", key, value);
				char *existing = hash_set(&k->server->keys, key, value);
				free(key);
				if (existing != value)
					free(existing);
			}

			a = pdu_reply(q, "OK", 0);

		} else if (strcmp(pdu_type(q), "DEL.KEYS") == 0 && pdu_size(q) > 1) {
			int i;
			char *key;
			for (i = 1; i < pdu_size(q); i++) {
				key = pdu_string(q, i);
				logger(LOG_INFO, "deleting key %s", key);
				free(hash_set(&k->server->keys, key, NULL));
				free(key);
			}
			a = pdu_reply(q, "OK", 0);

		} else if (strcmp(pdu_type(q), "SEARCH.KEYS") == 0 && pdu_size(q) == 2) {
			char *pattern;
			const char *re_err;
			int re_off;
			pcre *re;

			pattern = pdu_string(q, 1);
			re = pcre_compile(pattern, 0, &re_err, &re_off, NULL);

			if (!re) {
				a = pdu_reply(q, "ERROR", 1, re_err);
			} else {
				a = pdu_reply(q, "KEYS", 0);
				pcre_extra *re_extra = pcre_study(re, 0, &re_err);

				char *key, *value;
				for_each_key_value(&k->server->keys, key, value) {
					logger(LOG_DEBUG, "checking key '%s' against m/%s/", key, pattern);
					if (pcre_exec(re, re_extra, key, strlen(key), 0, 0, NULL, 0) != 0)
						continue;

					logger(LOG_INFO, "key '%s' matched m/%s/, adding to reply PDU", key, pattern);
					pdu_extendf(a, "%s", key);
				}

				pcre_free_study(re_extra);
				pcre_free(re);
			}
			free(pattern);

		} else if (strcmp(pdu_type(q), "DUMP") == 0 && pdu_size(q) == 2) {
			char *key  = pdu_string(q, 1);
			char *file = string(k->server->config.dumpfiles, key);
			free(key);

			dump(&k->server->db, file);
			a = pdu_reply(q, "DUMP", 1, file);
			free(file);

		} else if (strcmp(pdu_type(q), "CHECKFRESH") == 0 && pdu_size(q) == 1) {
			check_freshness(k);
			a = pdu_reply(q, "OK", 0);

		} else if (strcmp(pdu_type(q), "SAVESTATE") == 0 && pdu_size(q) == 1) {
			if (binf_write(&k->server->db, k->server->config.savefile) != 0) {
				a = pdu_reply(q, "ERROR", 1, "Internal Error");
			} else if (save_keys(&k->server->keys, k->server->config.keysfile) != 0) {
				a = pdu_reply(q, "ERROR", 1, "Internal Error");
			} else {
				a = pdu_reply(q, "OK", 0);
			}

		} else if (strcmp(pdu_type(q), "TICK") == 0 && pdu_size(q) == 1) {
			char *name;
			int32_t ts = time_s() - 15; /* FIXME: make configurable */

			counter_t *counter;
			for_each_key_value(&k->server->db.counters, name, counter) {
				if (counter->last_seen == 0 || winend(counter, counter->last_seen) >= ts)
					continue;
				broadcast_counter(k, counter);
				counter_reset(counter);
			}
			sample_t *sample;
			for_each_key_value(&k->server->db.samples, name, sample) {
				if (sample->last_seen == 0 || winend(sample, sample->last_seen) >= ts)
					continue;
				broadcast_sample(k, sample);
				sample_reset(sample);
			}
			a = pdu_reply(q, "OK", 0);
			free(name);

		} else {
			logger(LOG_WARNING, "kernel received an invalid [%s] PDU, of %i frames",
				pdu_type(q), pdu_size(q));
			a = pdu_reply(q, "ERROR", 1, "Invalid PDU");
		}

		logger(LOG_DEBUG, "sending back a [%s] PDU", pdu_type(a));
		pdu_send_and_free(a, k->listener);
		pdu_free(q);
	}

	pthread_cleanup_pop(1);
	return NULL;
}
