#!/usr/bin/perl

use strict;
use warnings;

sub usage
{
	my $s = shift || '';
	die "${s}USAGE: $0 <code> <host> <service> <summary>\n";
}

sub status
{
	local $_ = shift @_;
	return 0 if m/^ok(ay)?$/i;
	return 1 if m/^warn(ing)?$/i;
	return 2 if m/^crit(ical)?$/i;
	return 3 if m/^unk(n(own)?)?$/i;
	usage("bad status code '$_'\n");
}

sub sanitize
{
	join('', map {
		$_ == 0
			? '\0'
			: $_ > 0x1f && $_ < 0x7f
				? chr($_) : sprintf("\\x%02x", $_)
	} unpack("C*", $_[0]));
}

my @CRC32 = ();
for (my $i = 0; $i < 256; $i++) {
	my $crc = $i;
	for (my $j = 8; $j > 0; $j--) {
		if ($crc & 1) {
			$crc = ($crc >> 1) ^ 0xedb88320;
		} else {
			$crc >>= 1;
		}
		$CRC32[$i] = $crc;
	}
}

sub crc32
{
	my $crc = 0xffffffff;
	$crc = (($crc >> 8) & 0x00ffffff) ^ $CRC32[($crc ^ $_) & 0xff]
		for unpack("C*", $_[0]);
	return $crc;
}

my $code      = shift @ARGV or usage;
my $host      = shift @ARGV or usage;
my $service   = shift @ARGV or usage;
my $summary   = join(' ', @ARGV) or usage;
my $status    = status($code);
my $timestamp = time;

# an NSCA packet looks like this:
#
#   [   version   ]   16 bits
#   [    crc32    ]   32 bits
#   [  timestamp  ]   32 bits
#   [    status   ]   16 bits
#
#   [     host    ]   64 octets / null-padded
#   [   service   ]  128 octets / null-padded
#   [   summary   ] 4096 octets / null-padded

my $version = 1;
my $crc32 = 0;
my $raw = pack("nNNnZ64Z128Z4096",
	$version, $crc32, $timestamp, $status,
	$host, $service, $summary);
$crc32 = crc32($raw);

print "\t/* v=$version, ts=$timestamp, status=$status, crc32=$crc32 */\n";
print "\tmemset(nsca, 0, 4300); p = nsca;\n";

my $s = sanitize(pack("nNNn", $version, $crc32, $timestamp, $status));
my $l = length(qq{memcpy(p, "$s", 12);});
printf "\t%-${l}s p +=  12;\n", qq/memcpy(p, "$s", 12);/;
printf "\t%-${l}s p +=  64;\n", qq/memcpy(p, "$host", @{[length($host)]});/;
printf "\t%-${l}s p += 128;\n", qq/memcpy(p, "$service", @{[length($service)]});/;
printf "\t%s\n",              qq/memcpy(p, "$summary", @{[length($summary)]});/;
