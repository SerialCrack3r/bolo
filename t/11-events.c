#include "test.h"

#define EVENT(ts,name,extra)  do { \
	ok(pdu_send_and_free(pdu_make("NEW.EVENT", 3, #ts, name, extra), \
			kernel) == 0, "Sent " name " [NEW.EVENT] to kernel"); \
	CHECK(a = pdu_recv(kernel), "failed to get reply from kernel"); \
	is(pdu_type(a), "OK", "got [OK] from kernel"); \
} while (0)

#define EVENTS(ts, contents, m) do { \
	unlink("t/tmp/dump.file"); \
	ok(pdu_send_and_free(pdu_make("GET.EVENTS", 2, "file", #ts), \
		kernel) == 0, "Sent [GET.EVENTS] to kernel"); \
	CHECK(a = pdu_recv(kernel), "failed to get reply from kernel"); \
	is(pdu_type(a), "EVENTS", "got [EVENTS] from kernel"); \
	is(s = pdu_string(a, 1), "t/tmp/dump.file", "kernel returned file path"); \
	file_is(s, contents, m); \
	free(s); \
} while (0)

TESTS {
	mkdir("t/tmp", 0755);

	alarm(5);
	server_t svr; memset(&svr, 0, sizeof(svr));

	write_file("t/tmp/config",
		"# sample test config\n"
		"broadcast inproc://bcast\n"
		"dumpfiles t/tmp/dump.\%s\n"
		"savefile  t/tmp/save\n"
		"keysfile  t/tmp/keys\n"
		"max.events 3\n"
		"", 0);
	CHECK(configure("t/tmp/config", &svr) == 0,
		"failed to configure bolo");
	/* there is no savefile */
	unlink(svr.config.savefile);
	/* there is no keysfile */
	unlink(svr.config.keysfile);

	CHECK(svr.zmq = zmq_ctx_new(),
		"failed to create a new 0MQ context");

	pthread_t tid;
	CHECK(pthread_create(&tid, NULL, kernel, &svr) == 0,
		"failed to spin up kernel thread");
	sleep_ms(50);

	void *kernel;
	CHECK(kernel = zmq_socket(svr.zmq, ZMQ_DEALER),
		"failed to create mock kernel test socket");
	CHECK(zmq_connect(kernel, KERNEL_ENDPOINT) == 0,
		"failed to connect to kernel socket");

	/* ----------------------------- */

	pdu_t *a;
	char *s;

	/* put three events */
	EVENT(10001, "event.1", "the first event");
	EVENT(10002, "event.2", "the second event");
	EVENT(10003, "event.3", "the third event");

	EVENTS(0, "---\n"
		"# generated by bolo\n"
		"- name:  event.1\n"
		"  when:  10001\n"
		"  extra: the first event\n"
		"- name:  event.2\n"
		"  when:  10002\n"
		"  extra: the second event\n"
		"- name:  event.3\n"
		"  when:  10003\n"
		"  extra: the third event\n",
		"recorded all three events");

	EVENTS(10003, "---\n"
		"# generated by bolo\n"
		"- name:  event.3\n"
		"  when:  10003\n"
		"  extra: the third event\n",
		"filtered to events on or after timestamp 10003");

	/* send a fourth event */
	EVENT(10004, "event.4", "the fourth event");

	EVENTS(0, "---\n"
		"# generated by bolo\n"
		"- name:  event.2\n"
		"  when:  10002\n"
		"  extra: the second event\n"
		"- name:  event.3\n"
		"  when:  10003\n"
		"  extra: the third event\n"
		"- name:  event.4\n"
		"  when:  10004\n"
		"  extra: the fourth event\n",
		"only kept three events");

	svr.config.events_keep = EVENTS_KEEP_TIME;
	svr.config.events_max  = 2;

	EVENT(20001, "event.5", "the fifth event");
	EVENTS(0, "---\n"
		"# generated by bolo\n"
		"- name:  event.5\n"
		"  when:  20001\n"
		"  extra: the fifth event\n",
		"only kept the last two seconds of events");

	EVENT(20001, "event.6", "the sixth event");
	EVENT(20001, "event.7", "the seventh event");
	EVENT(20002, "event.8", "the eighth event");
	EVENTS(0, "---\n"
		"# generated by bolo\n"
		"- name:  event.5\n"
		"  when:  20001\n"
		"  extra: the fifth event\n"
		"- name:  event.6\n"
		"  when:  20001\n"
		"  extra: the sixth event\n"
		"- name:  event.7\n"
		"  when:  20001\n"
		"  extra: the seventh event\n"
		"- name:  event.8\n"
		"  when:  20002\n"
		"  extra: the eighth event\n",
		"kept all events in the last two seconds");

	EVENT(20003, "event.9", "the ninth event");
	EVENTS(0, "---\n"
		"# generated by bolo\n"
		"- name:  event.8\n"
		"  when:  20002\n"
		"  extra: the eighth event\n"
		"- name:  event.9\n"
		"  when:  20003\n"
		"  extra: the ninth event\n",
		"dropped the 20001 events (> 2s old)");

	EVENT(20010, "event.10", "the tenth event");
	EVENTS(0, "---\n"
		"# generated by bolo\n"
		"- name:  event.10\n"
		"  when:  20010\n"
		"  extra: the tenth event\n",
		"dropped all but the most recent event (> 2s old)");

	/* ----------------------------- */
	pthread_cancel(tid);
	pthread_join(tid, NULL);
	zmq_close(kernel);
}
